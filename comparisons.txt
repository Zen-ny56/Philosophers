1. while (i < shared->num_philo && /*shared->full_philos < shared->num_philo*/)
		{
			if (weigh_in(&philo[i]) == 0)
			{
				pthread_mutex_lock(&shared->lock);
				shared->full_philos++;
				pthread_mutex_unlock(&shared->lock);
			}
			i++;
		} // Ready for review

2. if ((*(philo->ravailable) == true) && (*(philo->lavailable) == true) 
		&& (philo->full == false)) // Ready for review

3. 	if (philo->is_eating == true) // Ready for review

4. void	notify(t_philo *philo)
{
	int i = 0;
	while (i < philo->info->num_philo)
	{
		pthread_mutex_lock(&philo->p_data);
		philo->is_dead = true;
		pthread_mutex_unlock(&philo->p_data);
		i++;
	}
// Ready for review;

5a. Make sure philo is just thinking when it's full // Ready for review

5b. Build routine for 6th parameter.

6. Free up memory and join threads.

-+******* Set flag for greedy // See if needed

-+*******. Check if a variables are shared by threads or changed by threads and set mutex_locks accordingly

What do I have 2 free & Mutexes to destroy & threads to join ?

Free
1. Data Struct
2. ap->available
3. ap->array
4. ap->fork
5. ap->philos

Mutexes
1.lock
2.write
3.p_data
4.picking_first
5.Array of forks

threads
1.Array of philo threads
2.Monitor thread
3.Waiter thread
